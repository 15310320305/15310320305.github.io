[{"title":"HDU6070(分数规划+线段树)","date":"2017-08-29T08:42:09.607Z","path":"2017/08/29/HDU6070（分数规划+线段树）/","text":"题目链接：HDU6070 题目大意：给你长度为n的序列，求某个区间[l,r]使得区间内的数字种类/区间长度最小 输出这个最小值 题目思路：对于这种区间最优比率问题（分数规划问题）我们常规的解法是二分答案来求 根据题目意思我们二分答案后可以转化成 size(l,r)/(r-l+1)&lt;=mid -&gt; size(l,r)+l*mid &lt;=(r+1)*mid 这里我们可以枚举右边的r ，然后用最值线段树来维护左边的最小值， 我们build的时候将线段树初始化为l*mid,然后对于枚举i,a[i]的贡献区间为 [pre[a[i]]+1,i]+1 因为如果前面已经存在了a[i]，该数就对之前的区间 没有贡献了 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;const int maxn = 6e4+50;const double esp = 1e-5;using namespace std;int a[maxn],last[maxn],pre[maxn],n;double tree[maxn&lt;&lt;2],c[maxn&lt;&lt;2];void pushup(int rt)&#123;tree[rt] = min(tree[rt&lt;&lt;1],tree[rt&lt;&lt;1|1]);&#125;void pushdown(int rt)&#123; if(c[rt]&gt;0) &#123; c[rt&lt;&lt;1]+=c[rt]; c[rt&lt;&lt;1|1]+=c[rt]; tree[rt&lt;&lt;1]+=c[rt]; tree[rt&lt;&lt;1|1]+=c[rt]; c[rt] = 0; &#125;&#125;void Build(int l,int r,int rt,double mid)&#123; c[rt] =0; if(l==r) &#123; tree[rt] = mid*l*1.0; return ; &#125; int Mid = (l+r)&gt;&gt;1; Build(l,Mid,rt&lt;&lt;1,mid); Build(Mid+1,r,rt&lt;&lt;1|1,mid); pushup(rt);&#125;void updata(int l,int r,int rt,int L,int R,double x)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; tree[rt]+=x; c[rt]+=x; return ; &#125; pushdown(rt); int mid = (l+r)&gt;&gt;1; if(L&lt;=mid) &#123; updata(l,mid,rt&lt;&lt;1,L,R,x); &#125; if(R&gt;mid) &#123; updata(mid+1,r,rt&lt;&lt;1|1,L,R,x); &#125; pushup(rt);&#125;double quary(int l,int r,int rt,int L,int R)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; return tree[rt]; &#125; pushdown(rt); int mid = (l+r)&gt;&gt;1; double res = 1e9; if(L&lt;=mid) &#123; res = min(res,quary(l,mid,rt&lt;&lt;1,L,R)); &#125; if(R&gt;mid) &#123; res = min(res,quary(mid+1,r,rt&lt;&lt;1|1,L,R)); &#125; return res;&#125;bool check(double mid)&#123; Build(1,n,1,mid); for(int i=1;i&lt;=n;i++) &#123; updata(1,n,1,pre[i]+1,i,1.0); if(quary(1,n,1,1,i)&lt;=mid*(i+1.0))return true; &#125; return false;&#125;int main()&#123; int t;cin&gt;&gt;t; while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); memset(last,0,sizeof(last)); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); if(last[a[i]]) &#123; pre[i] = last[a[i]]; &#125; else pre[i] = 0; last[a[i]] = i; &#125; double l = 0,r = 1.0,mid,ans; while(r-l&gt;esp) &#123; mid = (l+r)/2.0; if(check(mid))r = (ans=mid)-esp; else l = mid+esp; &#125; printf(&quot;%lf\\n&quot;,ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"hdu","slug":"hdu","permalink":"http://yoursite.com/tags/hdu/"},{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"}]},{"title":"Hello World","date":"2017-08-28T03:38:07.915Z","path":"2017/08/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]